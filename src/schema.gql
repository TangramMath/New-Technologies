# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateTeam {
  _count: TeamCountAggregate
  _max: TeamMaxAggregate
  _min: TeamMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type Mutation {
  createManyTeam(data: [TeamCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneTeam(data: TeamCreateInput!): Team!
  createOneUser(data: UserCreateInput!): User!
  deleteManyTeam(where: TeamWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneTeam(where: TeamWhereUniqueInput!): Team
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyTeam(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneTeam(create: TeamCreateInput!, update: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateTeam(cursor: TeamWhereUniqueInput, orderBy: [TeamOrderByWithRelationInput!], skip: Int, take: Int, where: TeamWhereInput): AggregateTeam!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstTeam(cursor: TeamWhereUniqueInput, distinct: [TeamScalarFieldEnum!], orderBy: [TeamOrderByWithRelationInput!], skip: Int, take: Int, where: TeamWhereInput): Team
  findFirstTeamOrThrow(cursor: TeamWhereUniqueInput, distinct: [TeamScalarFieldEnum!], orderBy: [TeamOrderByWithRelationInput!], skip: Int, take: Int, where: TeamWhereInput): Team
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  getTeam(where: TeamWhereUniqueInput!): Team
  getUser(where: UserWhereUniqueInput!): User
  groupByTeam(by: [TeamScalarFieldEnum!]!, having: TeamScalarWhereWithAggregatesInput, orderBy: [TeamOrderByWithAggregationInput!], skip: Int, take: Int, where: TeamWhereInput): [TeamGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  team(where: TeamWhereUniqueInput!): Team
  teams(cursor: TeamWhereUniqueInput, distinct: [TeamScalarFieldEnum!], orderBy: [TeamOrderByWithRelationInput!], skip: Int, take: Int, where: TeamWhereInput): [Team!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Team {
  _count: TeamCount
  id: String!
  name: String
  User(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type TeamCount {
  User: Int!
}

type TeamCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input TeamCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input TeamCreateInput {
  id: String
  name: String
  User: UserCreateNestedManyWithoutTeamsInput
}

input TeamCreateManyInput {
  id: String
  name: String
}

input TeamCreateNestedManyWithoutUserInput {
  connect: [TeamWhereUniqueInput!]
  connectOrCreate: [TeamCreateOrConnectWithoutUserInput!]
  create: [TeamCreateWithoutUserInput!]
}

input TeamCreateOrConnectWithoutUserInput {
  create: TeamCreateWithoutUserInput!
  where: TeamWhereUniqueInput!
}

input TeamCreateWithoutUserInput {
  id: String
  name: String
}

type TeamGroupBy {
  _count: TeamCountAggregate
  _max: TeamMaxAggregate
  _min: TeamMinAggregate
  id: String!
  name: String
}

input TeamListRelationFilter {
  every: TeamWhereInput
  none: TeamWhereInput
  some: TeamWhereInput
}

type TeamMaxAggregate {
  id: String
  name: String
}

input TeamMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type TeamMinAggregate {
  id: String
  name: String
}

input TeamMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input TeamOrderByRelationAggregateInput {
  _count: SortOrder
}

input TeamOrderByWithAggregationInput {
  _count: TeamCountOrderByAggregateInput
  _max: TeamMaxOrderByAggregateInput
  _min: TeamMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input TeamOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  User: UserOrderByRelationAggregateInput
}

enum TeamScalarFieldEnum {
  id
  name
}

input TeamScalarWhereInput {
  AND: [TeamScalarWhereInput!]
  id: StringFilter
  name: StringNullableFilter
  NOT: [TeamScalarWhereInput!]
  OR: [TeamScalarWhereInput!]
}

input TeamScalarWhereWithAggregatesInput {
  AND: [TeamScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  NOT: [TeamScalarWhereWithAggregatesInput!]
  OR: [TeamScalarWhereWithAggregatesInput!]
}

input TeamUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  User: UserUpdateManyWithoutTeamsNestedInput
}

input TeamUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
}

input TeamUpdateManyWithoutUserNestedInput {
  connect: [TeamWhereUniqueInput!]
  connectOrCreate: [TeamCreateOrConnectWithoutUserInput!]
  create: [TeamCreateWithoutUserInput!]
  delete: [TeamWhereUniqueInput!]
  deleteMany: [TeamScalarWhereInput!]
  disconnect: [TeamWhereUniqueInput!]
  set: [TeamWhereUniqueInput!]
  update: [TeamUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TeamUpdateManyWithWhereWithoutUserInput!]
  upsert: [TeamUpsertWithWhereUniqueWithoutUserInput!]
}

input TeamUpdateManyWithWhereWithoutUserInput {
  data: TeamUpdateManyMutationInput!
  where: TeamScalarWhereInput!
}

input TeamUpdateWithoutUserInput {
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
}

input TeamUpdateWithWhereUniqueWithoutUserInput {
  data: TeamUpdateWithoutUserInput!
  where: TeamWhereUniqueInput!
}

input TeamUpsertWithWhereUniqueWithoutUserInput {
  create: TeamCreateWithoutUserInput!
  update: TeamUpdateWithoutUserInput!
  where: TeamWhereUniqueInput!
}

input TeamWhereInput {
  AND: [TeamWhereInput!]
  id: StringFilter
  name: StringNullableFilter
  NOT: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  User: UserListRelationFilter
}

input TeamWhereUniqueInput {
  id: String
}

type User {
  _count: UserCount
  email: String!
  id: String!
  name: String!
  teams(cursor: TeamWhereUniqueInput, distinct: [TeamScalarFieldEnum!], orderBy: [TeamOrderByWithRelationInput!], skip: Int, take: Int, where: TeamWhereInput): [Team!]!
}

type UserCount {
  teams: Int!
}

type UserCountAggregate {
  _all: Int!
  email: Int!
  id: Int!
  name: Int!
}

input UserCountOrderByAggregateInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserCreateInput {
  email: String!
  id: String
  name: String!
  teams: TeamCreateNestedManyWithoutUserInput
}

input UserCreateManyInput {
  email: String!
  id: String
  name: String!
}

input UserCreateNestedManyWithoutTeamsInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutTeamsInput!]
  create: [UserCreateWithoutTeamsInput!]
}

input UserCreateOrConnectWithoutTeamsInput {
  create: UserCreateWithoutTeamsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutTeamsInput {
  email: String!
  id: String
  name: String!
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  email: String!
  id: String!
  name: String!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  email: String
  id: String
  name: String
}

input UserMaxOrderByAggregateInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

type UserMinAggregate {
  email: String
  id: String
  name: String
}

input UserMinOrderByAggregateInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserOrderByWithRelationInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
  teams: TeamOrderByRelationAggregateInput
}

enum UserScalarFieldEnum {
  email
  id
  name
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  email: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  email: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
}

input UserUpdateInput {
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  teams: TeamUpdateManyWithoutUserNestedInput
}

input UserUpdateManyMutationInput {
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input UserUpdateManyWithoutTeamsNestedInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutTeamsInput!]
  create: [UserCreateWithoutTeamsInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutTeamsInput!]
  updateMany: [UserUpdateManyWithWhereWithoutTeamsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutTeamsInput!]
}

input UserUpdateManyWithWhereWithoutTeamsInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateWithoutTeamsInput {
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input UserUpdateWithWhereUniqueWithoutTeamsInput {
  data: UserUpdateWithoutTeamsInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutTeamsInput {
  create: UserCreateWithoutTeamsInput!
  update: UserUpdateWithoutTeamsInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  email: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  teams: TeamListRelationFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
